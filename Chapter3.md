给极客的互联网计算机白皮书


(v1.0)

DFINITY团队[^1]

一月21日, 2022

**3 链钥(Chain-key)加密I:阈值签名**

IC链钥加密的一个关键组成部分是阈值签名方案[\[Des87\]](\l)。IC将阈值签名用于多种目的。设$n$为子网中的副本数量，设$f$为损坏副本数量的上限。  

-   *共识层利用基于$(f+1)$-out-of-$n$的阈值签名来实现一个随机信标(random beacon)(参见5.5节)。*

-   *执行层利用$(f+1)$-out-of-n阈值签名来实现一个随机带(random tape)，用于向容器提供不可预测的伪随机数(参见7.1节)。*

-   *执行层使用$(n-f)$-out-of-$n$阈值签名来证明复制的状态。这既用于验证子网的输出(参见6.1节)，也用于实现IC的链演化技术的快进(fast-forwarding)特性(参见8.2节)。*

对于前两个应用程序(随机信标和随机带)，阈值签名必须是唯一的，即对于给定的公钥和消息，只有一个有效签名。因为我们使用签名作为伪随机生成器的种子，并且所有计算这种阈值签名的副本必须同意统一的种子。

3.1  阈值BLS签名

我们采用基于BLS签名方案[\[BLS01\]](\l)实现阈值签名，该方案可以使调节阈值设置非常简单。普通的BLS(比如无阈值)签名方案利用了两个组$G$和$G'$,它们都是素阶$q$。我们假设$G$是由 $g\in G$生成的，$G'$是由$g'\in G'$生成的，假设一个哈希函数$H_{G’}$将其输入映射到$G'$(它被建模为一个随机的预言)。秘密签名密钥是元素$x\in Zq$，公共验证密钥是$V:=g^x \in G$。

在非阈值设置中，为了对消息m进行签名，签名者计算$h'\leftarrow H_{G'} (m) \in G'$,然后计算签名$\sigma: =(h')^x \in G'$。为了验证该签名是否有效，必须测试$log_{h'} \sigma=log_g V$。为了能够有效地执行这个测试，BLS方案在组$G$和$G’$上使用了**配对**的概念，这是一个特殊的代数工具，当$G$和$G’$是一种特殊类型的椭圆曲线时是可用的。这里我们不打算详细讨论成对和椭圆曲线，详情见[\[BLS01\]](\l)。BLS签名有一个很好的特性(上面提到过)，即签名是唯一的。

在$t$-out-of-$n$阈值设置中，我们有$n$个副本，其中任意$t$个副本都可以用于在消息上生成签名。更详细地说，每个副本$P_j$私自持有私密签名密钥$x \in Zq$的共享部分，$x_j \in Zq$，而群元素$V_j:=g^{xj}$是对外公开的。share$(x_1,...,x_n)$是一个$t$-out-of-$n$ 中的私密共享$x$ (参加3.4节)。

给定一个消息$m$，副本$P_j$可以生成一个**签名共享(signature share)：**

$$\sigma_j:=(h')^{x_j} \in G'$$

其中，如以前一样，$h':=H_G'(m)$。为了验证该签名是否有效，必须测试$log_h' \sigma_j =log_g V_j$。如上所述，这可以使用配对来完成——实际上，这与使用公钥Vj的普通BLS签名的有效性测试完全相同。
该方案满足以下**重构特性(reconstruction property):**

*给定任意$t$个有效签名集合在消息$m$上共享$\sigma_j$(由不同的副本贡献)，我们可以在公开验证密钥下高效地计算$m$上有效BLS签名$\sigma$。*

*事实上，$\sigma$可以计算为：*

$$\sigma \leftarrow \Pi_j  \sigma ^{\lambda j}_j$$

*其中，$\lambda_j$可以通过$t$贡献的副本指数有效地计算出来。*

在$G$的合理难度理性假设(reasonable intractability assumptions)下，将$H_{G'}$建模为随机oracle，该方案满足以下**安全特性(security property):**

假定最多有$f$个副本可能被对手破坏。那么，对手在消息上计算有效签名是不可行的，除非它至少从$t-f$诚信副本获得该消息上的签名共享。

3.2 分布式密钥分发

为了实现阈值BLS，我们需要一种方法来将秘密签名密钥的共享分发到副本。一种方法是让**受信任的一方(trusted party)**直接计算所有这些共享，并将它们分发到所有副本。但是可能会有的不好情况是，产生一个单点故障。相反，我们使用一个**分布式密钥生成(Distributed Key Generation, DKG)协议**，它允许副本使用一个安全的分布式协议本质上执行这样一个可信方的逻辑。
我们概述了当前实现的协议的顶层思想。读者可以参考[\[Gro21\]](\l)了解更多细节。所使用的DKG协议本质上是非交互式的。它使用两种基本成分:

* <b>一个公开可验证的秘密共享(Publicly Verifiable Secret Sharing，PVSS)方案；</b>

* 一个<b>共识</b>协议(consensus protocol)。

尽管可以使用任何共识协议，但我们使用的协议是第五节（也见第8节）中的协议。

3.3 假设

所作的基本假设与第一节中概述的相同: 

* 异步通信 ；

* $f<n/3$

我们只是间接地使用了部分同步假设(如第5.1节所述)来确保共识协议具有灵活性。
我们还假设对于$t$-out-$n$阈值签名方案，有

$$f<t \leq n-f$$

这可以保证（1）这些损坏的副本不能自己签名，（2）诚信的复制品可以自己签名。

我们还假设每个副本都与一些公钥相关联，其中每个副本还持有相应的私钥。其中一个公钥是签名密钥(与5.4节中的密钥相同)。另一个公钥是用于实现PVSS方案所需的特定公钥加密方案的公钥加密密钥(详细信息如下)。

3.4  PVSS方案

设$G$是上文引入的$g \in G$所生成的素阶$q$的群。令$s{\in Z}_q$是一个密钥, $s$的$t$-out-of-$n$的Shamir秘密享是一个向量 $(s_1,...,s_n) \in Z_q^n$ ，其中

$$s_j:=a(j)  (j=1,...,n)$$

以及

$$a(x):={a_0}+{a_1x}+...+{a_t}_-{_1}x^{t-1} \in Z_q[x]$$


是一个次数小于$t$的多项式，$a_0:=s$。

这样一个秘密sharing的关键性质有：

* 从$s_j$的$t$的任何集合，我们可以有效地计算(通过多项式插值)秘密$s=a_0=a(0)$，以及

* 如果$a_1,...,a_{t-1}$在$Z_q$上一致且独立地选择，则任意少于$s_j$的$t$的集合不会透露关于密钥$s$的信息。

在较高的层次上，PVSS方案允许一个副本$P_i$，也称为**交易者(dealer)**接受这样的共享，并计算一个名为**交易(dealing)**的对象，该对象包含

* 群元素的向量$(A_0,...,A_{t−1})$, 其中,$A_k:=g^{ak}$，$k=0,...,t-1$。

* 密文的向量$(c_1,...,c_n)$，其中$c_j$是$s_j$在$P_j$公共加密密钥下的加密,

* 一个非交互式的零知识证明$\pi$，每个$c_j$确实加密了这样一个共享——更准确地说，每个$C_j$解密$s_j$，并满足:

$$g^{sj}=\Pi_{k=0}^{t-1} A_k^{jk}=g^{a(j)}$$

我们注意到，要建立DKG协议的整体安全性，PVSS方案必须提供适当级别的选定密文安全性。具体来说,dealer必须嵌入其身份相关的数据处理,和加密的部分必须保持隐藏状态,即使选择密文攻击,敌人可以解密任意交易这有别于解密下相关数据关联的数据用来创建交易。

如果不太关注效率，PVSS方案是很容易实现的。这个想法是使用ElGamal-like加密方案对每个$S_j$一点点地加密，然后对关系(2)使用标准的非交互式零知识证明，该证明将基于Fiat-Shamir变换的标准应用（参见[\[FS86\]](\l)制定适当的Sigma协议(参见[\[CDS94\]](\l)。虽然这产生了一个多项式时间的方案，它不是那么实际。然而，有许多可能的方法来优化这种类型的方案。关于IC中使用的高度优化的PVSS方案的详细信息，请参阅[\[Gro21\]](\l)。

3.5 基础DKG协议

使用PVSS方案和一个共识协议，基本的DKG协议非常简单。

-   1.每个副本向所有其他副本广播一个随机秘密的签名交易。这样一个签名的交易包括一个交易，连同交易者(dealer)的身份和交易者的公开签名密钥下的交易签名。
这种签名交易的语法形式正确，且签名和非交互式零知识证明有效，称为有效交易。

-   2.使用共识，副本在$f+1$集合$S$有效签署的交易(来自不同的交易者)达成一致。

-   3.假设集合$S$中的第i个元素包含了群元素的向量$(A_{i,0},...A_{i,t-1})$和密文的向量$(c_{i,1},...c_{i,n})$。

则阈值签名方案的公开验证密钥为：

$$V=\Pi_i A_{i,0}$$

注意，私密签名密钥隐式定义为

$$x:=log_gV$$

$P_j$在私密签名密钥x中的共享部分为

$$xj:=\Sigma_i s_{i,j}$$

其中$s_{i,j}$是$c_{i,j}$在$P_j$的秘密解密密钥下的解密。
副本$P_j$的公开验证密钥为:

$$vj:=\Pi_i \Pi_{k=0}^{t-1} A^{jk}_{i,k}=g^{xj}$$

值得注意的是，共享$x_j$包含了$x$的$t$-out-of-$n$ 的Shamir秘密共享。因此，(1)中出现的$\lambda_j$值只是拉格朗日插值系数。这就建立了章节3.1中所述的重构特性。对于3.1节中所述的安全特性，可以证明将$H{G’}$建模为随机预言, 并假设PVSS方案是安全的, 而且群$G$和$G’$（配对）满足**一对多的Diffie-Hellman硬度假设(one-more Diffie-Hellman hardness assumption)。**可以这么说，没有一个有效的对手可以在没有疏忽的情况下赢得接下来的游戏。
挑战者随机选择了$\mu_1,...,\mu_k \in Z_q$以及$v_1,...,v_l \in Z_q$，并$\lbrace g^{\mu i} \rbrace ^k_{i=1}$，以及$\lbrace(g')^{vj}\rbrace ^l_{j=1}$给了对手

对手向挑战者提出一连串的查询，每一个查询都是一个向量，其形式为$\lbrace k_{i,j} \rbrace_{i,j}$。挑战者的回应是:

$$\Pi_{i,j} ((g')^{\mu i v j})^{ki,j}$$

为了结束游戏，对手输出一个向量$\lbrace \lambda_{i,j} \rbrace_{i,j}$和一个组元素$h' \in G'$, 满足如下公式可赢得游戏：

$$h'=\Pi((g')^{\mu i v j})^{\lambda i,j}$$

输出向量$\lbrace {\mu_i,j}\rbrace_i,j$不是查询向量的线性组合。
虽然在$t>f+1$的情况下需要这种类型的一对多的Diffie-Hellman假设，但当$t=f+1$时，可以采用较弱的假设(所谓的co-CDH假设，普通BLS方案的安全性是基于该假设的)。

3.6 再共享协议

可以很容易地修改基本DKG协议，这样它就可以创建一个新的、随机的秘密$x$，而不是一个创造一个新的、随机的秘密$x$的共享部分(sharing)。

* 基本协议的第1步被修改，以便每个副本广播其现有share的一个签名交易。

* 修改步骤2，以达成一套有效的签署交易。另外,每个交易被核实，以确保它确实是一个适当的现有share的交易(这意味着在第$A_{i,0}$次交易中的价值应该等于之前的旧值的$V_i$)。

* 在步骤3中，在拉格朗日插值系数$i$上计算新的$x_j$(和$V_j$)值权重的总和(和乘积)。